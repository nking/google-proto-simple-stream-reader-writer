<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
    "http://www.w3.org/TR/html4/loose.dtd">
<html>
    <head>
        <script type="text/javascript" src="/js/jquery-1.6.4.min.js"></script>
        <link rel="stylesheet" href="stylesheets/qunit.css" type="text/css" media="screen" />
        <script type="text/javascript" src="/js/qunit.js"></script>
        <script type="text/javascript" src="/js/protobuf.js"></script>
        <script type="text/javascript" src="/js/pbj.js"></script>
        <script type="text/javascript" src="/js/googleProtocolBufferMessagesReader.js"></script>
        <script type="text/javascript" src="/js/googleProtocolBufferMessagesAjaxHelper.js"></script>
        <script type="text/javascript" src="/js/examplemessage.proto.js"></script>

        <script>
            var gpburl = "http://localhost:8080/gpb";

            var retryCount = 0;
            var timeoutInMillis = 15000;

            var createYourPROTOMessage1 = function() {
                return new com.climbwithyourfeet.proto.ExampleMessages;
            };
            var createYourPROTOMessage2 = function() {
                return new com.climbwithyourfeet.proto.ExampleMsg;
            };

            function printPass(testNumber, testDesc) {
                writeToElement.innerHTML = writeToElement.innerHTML
                    + "<br/>(" + testNumber + "), "
                    + "<b style='color:green;'>passed</b> " + testDesc;
            }
            function printFail(testNumber, testDesc, msg) {
                writeToElement.innerHTML = writeToElement.innerHTML
                    + "<br/>(" + testNumber + "), "
                    + "<b style='color:red;'>failed</b> " + testDesc
                    + "<b style='color:red;'>; ERROR:" + msg + "</b>";
            }

            $(document).ready(function() {

                var testNumber = 0;

                writeToElement.innerHTML = "<br/><b>[" + navigator.userAgent + "]</b>";

                asyncTest("makeXMLHttpRequestForArrayBufferWithTypedArray (no delimiters)", function() {
                    testNumber++;
                    var testDesc = 'XMLHttpRequest + ArrayBuffer + text + TypedArray + (no delimiters)';
                    expect( 1 );

                    var successCallback = function(messages) {
                        start();
                        var pass = (messages != undefined) && (messages.msg != undefined);
                        pass = pass && (messages.msg.length > 0);
                        var pbMessage = messages.msg[0];
                        pass = pass && (pbMessage.name != undefined) && (pbMessage.value != undefined) && (pbMessage.code != undefined);
                        ok(pass, 'request and deserialization worked');
                        if (pass) {
                            printPass(testNumber, testDesc);
                        } else {
                            printFail(testNumber, testDesc, 'deserialized msg missing properties');
                        }
                    }
                    var errorCallback = function(msg) {
                        start();
                        ok(false, 'failed for request and parse');
                        printFail(testNumber, testDesc, msg);
                    }
                    try {
                        makeXMLHttpRequestForArrayBufferWithTypedArrayNoDelimiters(gpburl + '?useDelimiters=false', successCallback, errorCallback, createYourPROTOMessage1, timeoutInMillis);
                    } catch(e) {
                        errorCallback(e.message);
                    }
                });

                asyncTest("makeXMLHttpRequestWithoutArrayBuffer (no delimiters)", function() {
                    testNumber++;
                    var testDesc = 'XMLHttpRequest + text + (no delimiters)';
                    expect( 1 );

                    var successCallback = function(messages) {
                        start();
                        var pass = (messages != undefined) && (messages.msg != undefined);
                        pass = pass && (messages.msg.length > 0);
                        var pbMessage = messages.msg[0];
                        pass = pass && (pbMessage.name != undefined) && (pbMessage.value != undefined) && (pbMessage.code != undefined);
                        ok(pass, 'request and deserialization worked');
                        if (pass) {
                            printPass(testNumber, testDesc);
                        } else {
                            printFail(testNumber, testDesc, 'deserialized msg missing properties');
                        }
                    }
                    var errorCallback = function(msg) {
                        start();
                        ok(false, 'failed for request and parse');
                        printFail(testNumber, testDesc, msg);
                    }

                    try {
                        makeXMLHttpRequestWithoutArrayBufferNoDelimiters(gpburl + '?useDelimiters=false', successCallback, errorCallback, createYourPROTOMessage1, timeoutInMillis);
                    } catch(e) {
                        errorCallback(e.message);
                    }
                });

                asyncTest("makeXDomainRequest (no delimiters)", function() {
                    testNumber++;
                    var testDesc = 'XDomainRequest + text + (no delimiters)';
                    expect( 1 );

                    var successCallback = function(messages) {
                        start();
                        var pass = (messages != undefined) && (messages.msg != undefined);
                        pass = pass && (messages.msg.length > 0);
                        var pbMessage = messages.msg[0];
                        pass = pass && (pbMessage.name != undefined) && (pbMessage.value != undefined) && (pbMessage.code != undefined);
                        ok(pass, 'request and deserialization worked');
                        if (pass) {
                            printPass(testNumber, testDesc);
                        } else {
                            printFail(testNumber, testDesc, 'deserialized msg missing properties');
                        }
                    }
                    var errorCallback = function(msg) {
                        start();
                        ok(false, 'failed for request and parse');
                        printFail(testNumber, testDesc, msg);
                    }

                    try {
                        makeXDomainRequestNoDelimiters(gpburl + '?useDelimiters=false', successCallback, errorCallback, createYourPROTOMessage1, timeoutInMillis);
                    } catch(e) {
                        errorCallback(e.message);
                    }
                });

                asyncTest("makeActiveXObjectRequest (no delimiters)", function() {
                    testNumber++;
                    var testDesc = 'ActiveXObjectRequest + text + (no delimiters)';
                    expect( 1 );

                    var successCallback = function(messages) {
                        start();
                        var pass = (messages != undefined) && (messages.msg != undefined);
                        pass = pass && (messages.msg.length > 0);
                        var pbMessage = messages.msg[0];
                        pass = pass && (pbMessage.name != undefined) && (pbMessage.value != undefined) && (pbMessage.code != undefined);
                        ok(pass, 'request and deserialization worked');
                        if (pass) {
                            printPass(testNumber, testDesc);
                        } else {
                            printFail(testNumber, testDesc, 'deserialized msg missing properties');
                        }
                    }
                    var errorCallback = function(msg) {
                        start();
                        ok(false, 'failed for request and parse');
                        printFail(testNumber, testDesc, msg);
                    }

                    try {
                        makeActiveXObjectRequestNoDelimiters(gpburl + '?useDelimiters=false',
                            successCallback, errorCallback, createYourPROTOMessage1, timeoutInMillis);
                    } catch(e) {
                        errorCallback(e.message);
                    }
                });

                asyncTest("makeXMLHttpRequestSync (no delimiters)", function() {
                    testNumber++;
                    var testDesc = 'XMLHttpRequest + synchronous + text + (no delimiters)';
                    expect( 1 );

                    var successCallback = function(messages) {
                        start();
                        var pass = (messages != undefined) && (messages.msg != undefined);
                        pass = pass && (messages.msg.length > 0);
                        var pbMessage = messages.msg[0];
                        pass = pass && (pbMessage.name != undefined) && (pbMessage.value != undefined) && (pbMessage.code != undefined);
                        ok(pass, 'request and deserialization worked');
                        if (pass) {
                            printPass(testNumber, testDesc);
                        } else {
                            printFail(testNumber, testDesc, 'deserialized msg missing properties');
                        }
                    }
                    var errorCallback = function(msg) {
                        start();
                        ok(false, 'failed for request and parse');
                        printFail(testNumber, testDesc, msg);
                    }

                    try {
                        makeSyncXMLHttpRequestNoDelimiters(gpburl + '?useDelimiters=false', successCallback, errorCallback, createYourPROTOMessage1);
                    } catch(e) {
                        errorCallback(e.message);
                    }
                });

                asyncTest("makeSyncActiveXObjectRequest (no delimiters)", function() {
                    testNumber++;
                    var testDesc = 'ActiveXObject + synchronous + text + (no delimiters)';
                    expect( 1 );

                    var successCallback = function(messages) {
                        start();
                        var pass = (messages != undefined) && (messages.msg != undefined);
                        pass = pass && (messages.msg.length > 0);
                        var pbMessage = messages.msg[0];
                        pass = pass && (pbMessage.name != undefined) && (pbMessage.value != undefined) && (pbMessage.code != undefined);
                        ok(pass, 'request and deserialization worked');
                        if (pass) {
                            printPass(testNumber, testDesc);
                        } else {
                            printFail(testNumber, testDesc, 'deserialized msg missing properties');
                        }
                    }
                    var errorCallback = function(msg) {
                        start();
                        ok(false, 'failed for request and parse');
                        printFail(testNumber, testDesc, msg);
                    }

                    try {
                        makeSyncActiveXObjectRequestNoDelimiters(gpburl + '?useDelimiters=false&c=' + (new Date()).getTime(),
                            successCallback, errorCallback, createYourPROTOMessage1);
                    } catch(e) {
                        errorCallback(e.message);
                    }
                });

                asyncTest("makeXMLHttpRequestForArrayBufferWithTypedArray (w/ delimiters)", function() {
                    testNumber++;
                    var testDesc = 'XMLHttpRequest + ArrayBuffer + text + TypedArray + (w/ delimiters)';
                    expect( 1 );

                    var successCallback = function(messages) {
                        start();
                        var pass = (messages != undefined);
                        pass = pass && (messages.length > 0);
                        var pbMessage = messages[0];

                        pass = pass && (pbMessage.name != undefined) && (pbMessage.value != undefined) && (pbMessage.code != undefined);
                        ok(pass, 'request and deserialization worked');
                        if (pass) {
                            printPass(testNumber, testDesc);
                        } else {
                            printFail(testNumber, testDesc, 'deserialized msg missing properties');
                        }
                    }
                    var errorCallback = function(msg) {
                        start();
                        ok(false, 'failed for request and parse');
                        printFail(testNumber, testDesc, msg);
                    }

                    var m = [];
                    var perMessageCallback = function renderEvent(gpbMessage, dictionary) {
                        m.push(gpbMessage);
                    };
                    var completedCallback = function deserializationIsDone(dictionary) {
                        successCallback(m);
                    };
                    var errorHandle = function(errorString, dictionary) {
                        errorCallback(errorString);
                    };
                    var userdictionary = {'key': "key"};

                    try {
                        makeXMLHttpRequestForArrayBufferWithTypedArray(gpburl, createYourPROTOMessage2,
                            perMessageCallback, completedCallback, errorHandle, userdictionary, timeoutInMillis);
                    } catch(e) {
                        errorCallback(e.message);
                    }
                });

                asyncTest("makeXMLHttpRequestWithoutArrayBuffer (w/ delimiters)", function() {
                    testNumber++;
                    var testDesc = 'XMLHttpRequest + text + (w/ delimiters)';
                    expect( 1 );

                    var successCallback = function(messages) {
                        var pass = (messages != undefined);
                        pass = pass && (messages.length > 0);
                        var pbMessage = messages[0];
                        pass = pass && (pbMessage.name != undefined) && (pbMessage.value != undefined) && (pbMessage.code != undefined);
                        ok(pass, 'request and deserialization worked');
                        if (pass) {
                            printPass(testNumber, testDesc);
                        } else {
                            printFail(testNumber, testDesc, 'deserialized msg missing properties');
                        }
                        start();
                    }
                    var errorCallback = function(msg) {
                        ok(false, 'failed for request and parse');
                        printFail(testNumber, testDesc, msg);
                        start();
                    }

                    var m = [];
                    var perMessageCallback = function renderEvent(gpbMessage, dictionary) {
                        m.push(gpbMessage);
                    };
                    var completedCallback = function deserializationIsDone(dictionary) {
                        successCallback(m);
                    };
                    var errorHandle = function(errorString, dictionary) {
                        errorCallback(errorString);
                    };
                    var userdictionary = {'key': "key"};

                    try {
                        makeXMLHttpRequestWithoutArrayBuffer(gpburl, createYourPROTOMessage2,
                            perMessageCallback, completedCallback, errorHandle, userdictionary, timeoutInMillis);
                    } catch(e) {
                        errorCallback(e.message);
                    }
                });

                asyncTest("makeXDomainRequest (w/ delimiters)", function() {
                    testNumber++;
                    var testDesc = 'XDomainRequest + text + (w/ delimiters)';
                    expect( 1 );

                    var successCallback = function(messages) {
                        var pass = (messages != undefined);
                        pass = pass && (messages.length > 0);
                        var pbMessage = messages[0];
                        pass = pass && (pbMessage.name != undefined) && (pbMessage.value != undefined) && (pbMessage.code != undefined);
                        ok(pass, 'request and deserialization worked');
                        if (pass) {
                            printPass(testNumber, testDesc);
                        } else {
                            printFail(testNumber, testDesc, 'deserialized msg missing properties');
                        }
                        start();
                    }
                    var errorCallback = function(msg) {
                        ok(false, 'failed for request and parse');
                        printFail(testNumber, testDesc, msg);
                        start();
                    }

                    var m = [];
                    var perMessageCallback = function renderEvent(gpbMessage, dictionary) {
                        m.push(gpbMessage);
                    };
                    var completedCallback = function deserializationIsDone(dictionary) {
                        successCallback(m);
                    };
                    var errorHandle = function(errorString, dictionary) {
                        errorCallback(errorString);
                    };
                    var userdictionary = {'key': "key"};

                    try {
                        makeXDomainRequest(gpburl, createYourPROTOMessage2, perMessageCallback, completedCallback, errorHandle, userdictionary, timeoutInMillis);
                    } catch(e) {
                        errorCallback(e.message);
                    }
                });

                asyncTest("makeActiveXObjectRequest (w/ delimiters)", function() {
                    testNumber++;
                    var testDesc = 'ActiveXObjectRequest + text + (w/ delimiters)';
                    expect( 1 );

                    var successCallback = function(messages) {
                        var pass = (messages != undefined);
                        pass = pass && (messages.length > 0);
                        var pbMessage = messages[0];
                        pass = pass && (pbMessage.name != undefined) && (pbMessage.value != undefined) && (pbMessage.code != undefined);
                        ok(pass, 'request and deserialization worked');
                        if (pass) {
                            printPass(testNumber, testDesc);
                        } else {
                            printFail(testNumber, testDesc, 'deserialized msg missing properties');
                        }
                        start();
                    }
                    var errorCallback = function(msg) {
                        start();
                        ok(false, 'failed for request and parse');
                        printFail(testNumber, testDesc, msg);
                    }

                    var m = [];
                    var perMessageCallback = function renderEvent(gpbMessage, dictionary) {
                        m.push(gpbMessage);
                    };
                    var completedCallback = function deserializationIsDone(dictionary) {
                        successCallback(m);
                    };
                    var errorHandle = function(errorString, dictionary) {
                        errorCallback(errorString);
                    };
                    var userdictionary = {'key': "key"};

                    try {
                        makeActiveXObjectRequest(gpburl, createYourPROTOMessage2, perMessageCallback, completedCallback, errorHandle, userdictionary, timeoutInMillis);
                    } catch(e) {
                        errorCallback(e.message);
                    }
                });

                test("makeXMLHttpRequestSync (w/ delimiters)", function() {
                    testNumber++;
                    var testDesc = 'XMLHttpRequest + synchronous + text + (w/ delimiters)';
                    expect( 1 );

                    var successCallback = function(messages) {

                        var pass = (messages != undefined);
                        pass = pass && (messages.length > 0);
                        var pbMessage = messages[0];
                        pass = pass && (pbMessage.name != undefined) && (pbMessage.value != undefined) && (pbMessage.code != undefined);
                        ok(pass, 'request and deserialization worked');
                        if (pass) {
                            printPass(testNumber, testDesc);
                        } else {
                            printFail(testNumber, testDesc, 'deserialized msg missing properties');
                        }
                        start();
                    }
                    var errorCallback = function(msg) {

                        ok(false, 'failed for request and parse');
                        printFail(testNumber, testDesc, msg);
                        start();
                    }

                    var m = [];
                    var perMessageCallback = function renderEvent(gpbMessage, dictionary) {
                        m.push(gpbMessage);
                    };
                    var completedCallback = function deserializationIsDone(dictionary) {
                        successCallback(m);
                    };
                    var errorHandle = function(errorString, dictionary) {
                        errorCallback(errorString);
                    };
                    var userdictionary = {'key': "key"};

                    try {
                        makeSyncXMLHttpRequest(gpburl, createYourPROTOMessage2, perMessageCallback, completedCallback, errorHandle, userdictionary);
                    } catch(e) {
                        errorCallback(e.message);
                    }
                });

                test("makeSyncActiveXObjectRequest (w/ delimiters)", function() {
                    testNumber++;
                    var testDesc = 'ActiveXObject + synchronous + text + (w/ delimiters)';
                    expect( 1 );

                    var successCallback = function(messages) {

                        var pass = (messages != undefined);
                        pass = pass && (messages.length > 0);
                        var pbMessage = messages[0];
                        pass = pass && (pbMessage.name != undefined) && (pbMessage.value != undefined) && (pbMessage.code != undefined);
                        ok(pass, 'request and deserialization worked');
                        if (pass) {
                            printPass(testNumber, testDesc);
                        } else {
                            printFail(testNumber, testDesc, 'deserialized msg missing properties');
                        }
                        start();
                    }
                    var errorCallback = function(msg) {

                        ok(false, 'failed for request and parse');
                        printFail(testNumber, testDesc, msg);
                        start();
                    }

                    var m = [];
                    var perMessageCallback = function renderEvent(gpbMessage, dictionary) {
                        m.push(gpbMessage);
                    };
                    var completedCallback = function deserializationIsDone(dictionary) {
                        successCallback(m);
                    };
                    var errorHandle = function(errorString, dictionary) {
                        errorCallback(errorString);
                    };
                    var userdictionary = {'key': "key"};

                    try {
                        makeSyncActiveXObjectRequest(gpburl, createYourPROTOMessage2, perMessageCallback, completedCallback, errorHandle, userdictionary);
                    } catch(e) {
                        errorCallback(e.message);
                    }
                });
            });

        </script>

    </head>
    <body>
        <h1 id="qunit-header">QUnit test for Javascript Google Protocol Buffer libraries</h1>
        <h2 id="qunit-banner"></h2>
        <div id="qunit-testrunner-toolbar"></div>
        <h2 id="qunit-userAgent"></h2>
        <ol id="qunit-tests"></ol>
        <div id="qunit-fixture">test markup, will be hidden</div>
        <div id="output"></div>
        <br/>

        <script type='text/javascript'>
            writeToElement = document.getElementById('output');
        </script>
    </body>
</html>
